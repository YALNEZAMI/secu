Dans la suite du TP, on vous incite fortement Ã  utiliser la notation Ã  lâ€™aide des await et async. Cette notation permet Ã©galement dâ€™utiliser les promesses avec .then si besoin.

Step 5: Petit projet
Q3:
A partir de la documentation de lâ€™API du FS, fabriquer une mÃ©thode printFileWithSizeEqualNul attachÃ© Ã  la classe Repertoire qui, Ã  partir de la structure de donnÃ©es prÃ©alablement crÃ©Ã©e (Fichier, RÃ©pertoire, FsElement), explore ce graphe pour dÃ©tecter les fichiers donc la taille est zero. On rappelle que la taille dâ€™un rÃ©pertoire est la somme des tailles de ces Ã©lÃ©ments. Il faudra prÃ©alablement crÃ©er la fonction qui crÃ©e le graphe dâ€™objet instance de Repertoire et Fichier Ã  partir du chemin dâ€™un rÃ©pertoire donnÃ© en paramÃ¨tre.

:ticket: Pour lister les fichier dâ€™un rÃ©pertoire, vous pouvez utiliser la fonction

fs.readdir(path)
:ticket: Pour savoir si un Ã©lement contenu dans un rÃ©pertoire est un rÃ©pertoire ou un fichier, la fonction fs.stat() vue prÃ©cÃ©demment retourne un objet sur lequel on a accÃ¨s Ã  lâ€™API suivante.

stats.isDirectory()
:ticket: De mÃªme, pour connaÃ®tre la taille dâ€™un fichier Ã  lâ€™aide de lâ€™api fs; on utilisera lâ€™attribut size de lâ€™objet retournÃ© par fs.stat().

stats.size
:ticket: Enfin, nâ€™oubliez pas vos cours sur la rÃ©cursivitÃ© afin de crÃ©er un graphe complet.

:ticket: Automatisation de la phase de compilation. Recompiler Ã  chaque fois que lâ€™on souhaite tester lâ€™exÃ©cution, câ€™est fastidieux. Il est classique dâ€™utiliser des mÃ©canismes qui vont surveiller lâ€™Ã©tat du systÃ¨me de fichier et dÃ©clencher la compilation pour vous. Pour ce faire, Ã  la racine du projet, lancer la commande:

tsc --watch
Cela lance un processus qui surveille tous vos fichiers typescript et relance la compilation quand un fichier ts est modifiÃ©.

Q4:
Etendez votre structure de donnÃ©es pour ajouter la notion de permission et vÃ©rifier de maniÃ¨re rÃ©cursive quâ€™aucun enfant nâ€™a des permissions moins restrictives quâ€™un de ses parents. De nouveau, on modifiera la fonction qui permet de crÃ©er le graphe dâ€™objets Repertoire et Fichier Ã  partir dâ€™un chemin donnÃ© sous forme de chaine de caractÃ¨res et on ajoutera une mÃ©thode Ã  la classe rÃ©pertoire pour la partie vÃ©rification de droits.

Step 6: Comprendre certains aspects du systÃ¨me de type
Par dÃ©faut, en TypeScript nous avons pas mal de flexibilitÃ© sur la configuration du typechecker (configuration au niveau du fichier tsconfig.json). En effet, diffÃ©rents utilisateurs viennent Ã  TypeScript en recherchant diffÃ©rentes choses dans un vÃ©rificateur de type. Certains recherchent une expÃ©rience plus souple qui peut aider Ã  valider seulement certaines parties de leur programme, tout en disposant dâ€™un outil dÃ©cent. Câ€™est lâ€™expÃ©rience par dÃ©faut avec TypeScript (pas celle configurÃ© dans notre projet), oÃ¹ les types sont optionnels, lâ€™infÃ©rence prend les types les plus indulgents, et il nâ€™y a pas de vÃ©rification pour les valeurs potentiellement nulles ou indÃ©finies. Ces valeurs par dÃ©faut sont mises en place pour ne pas vous gÃªner. Si vous migrez du JavaScript existant, cela peut Ãªtre une premiÃ¨re Ã©tape souhaitable.

En revanche, beaucoup dâ€™utilisateurs prÃ©fÃ¨rent que TypeScript valide le plus possible dÃ¨s le dÃ©part, et câ€™est pourquoi le langage fournit Ã©galement des paramÃ¨tres de demande de rigueur forte, câ€™est notre cas dans ce projet. Utiliser une demande de rigueur plus forte peut nÃ©cessiter un peu de travail supplÃ©mentaire, mais en gÃ©nÃ©ral cela se paie sur le long terme, et permet des vÃ©rifications plus approfondies et des outils plus prÃ©cis. Lorsque cela est possible, une nouvelle base de code devrait toujours activer ces vÃ©rifications. Prenons lâ€™exemple de deux dâ€™entres elles.

noImplicitAny
Rappelons quâ€™Ã  certains endroits, TypeScript nâ€™essaie pas de dÃ©duire les types pour nous et se rabat sur le type le plus indulgent : any. Ce nâ€™est pas la pire chose qui puisse arriver - aprÃ¨s tout, se rabattre sur any est juste lâ€™expÃ©rience JavaScript ordinaire de toute faÃ§on.
Any est le (void*) de C++, cela desactive toute vÃ©rification de type. Un objet de type any peut Ãªtre affectÃ© Ã  nâ€™importe quelle variable quelque soit sont type, on peut lui appeler nâ€™importe quelle mÃ©thode â€¦

Cependant, lâ€™utilisation de any va souvent Ã  lâ€™encontre de la raison dâ€™Ãªtre de TypeScript. Plus votre programme est typÃ©, plus vous obtiendrez de validation et dâ€™outils, ce qui signifie que vous rencontrerez moins de bugs lorsque vous coderez. Activer le drapeau noImplicitAny dans le fichier tsconfig.json provoquera une erreur sur toutes les variables dont le type est implicitement dÃ©duit comme Ã©tant any.

ContrÃ´les stricts de nullitÃ©

Par dÃ©faut, les valeurs telles que null et undefined sont assignables Ã  nâ€™importe quel autre type. Cela peut faciliter lâ€™Ã©criture de certains codes, mais oublier de gÃ©rer les valeurs null et undefined est la cause dâ€™innombrables bogues dans le monde - certains considÃ¨rent que câ€™est lâ€™erreur Ã  un milliard de dollars ! Lâ€™option strictNullChecks rend la gestion de null et undefined plus explicite et nous Ã©vite de nous soucier de savoir si nous avons oubliÃ© de gÃ©rer null et undefined. Mettre cette valeur Ã  true empÃªchera par exemple aussi de laisser une variable dÃ©clarÃ©e comme une chaÃ®ne de caractÃ¨re au type non dÃ©fini. Dâ€™un point de vue typage, null et undefined ne deviennent plus des valeurs acceptables pour les types existants. Pour autoriser une valeur undefined, il faudra alors dire explicitement quâ€™une variable peut Ãªtre une chaÃ®ne de caractÃ¨re par exemple ou undefined en utilisant les union de type.

name: string |undefined 
Nous pourrons aussi utiliser la notion de propriÃ©tÃ© optionnelle si câ€™est un attribut dâ€™une classe, dâ€™une interface, un paramÃ¨tre dâ€™une fonction Ã  lâ€™aide de la notation suivante:

name?: string 
Q5:
Dans notre classe Fichier, ajoutez un attribut est_lie_a qui en tant que rÃ©fÃ©rence optionnel vers un autre objet.

Je vous donne la syntaxe dans lâ€™extrait de code ci-dessous

est_lie_a?: FsElement // FsElement est le nom de votre interface crÃ©Ã©e Ã  la question 1
CrÃ©er ensuite une mÃ©thode affiche_est_lie_a qui affiche dans la console le nom de lâ€™Ã©lement auquel est liÃ© un fichier. Pour cela nous allons tester plusieurs syntaxe

affiche_est_lie_a():void{
    console.log('liÃ© Ã  :', this.est_lie_a.nom)
} 
affiche_est_lie_a():void{
    if (this.est_lie_a !== undefined){
        console.log('liÃ© Ã  :', this.est_lie_a.nom)    
    }
} 
affiche_est_lie_a():void{
        console.log('liÃ© Ã  :', this.est_lie_a?.nom)    
} 
C
AprÃ¨s un Ã©change avec votre intervant de TP, la lecture des rÃ©fÃ©rences suivantes, prÃ©senter dans le compte rendu de TP avec vos mots les avantages et/ou les inconvÃ©nients de chacun des codes ci-dessus. Certains codes peuvent provoquer des erreurs Ã  la compilation ou Ã  lâ€™exÃ©cution. Vous discuterez le pourquoi de ces erreurs.

[6] https://askjavascript.com/exclamation-mark-or-bang-operator-in-typescript-when-dereferencing/

[7] https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#optional-properties
[8] https://www.typescriptlang.org/docs/handbook/2/objects.html#optional-properties

Step 7: Placement de ce projet sur git
Maintenant que le squelette est en place, nous allons placer ce code sur git.

CrÃ©er un blank project sur le gitlab de lâ€™istic. https://gitlab.istic.univ-rennes1.fr/

:warning: DÃ©sÃ©lectionnez Initialize repository with a README afin de garder un repo complÃ¨tement vide.


# Configurer git sur votre machine, 
# âš ï¸ Ã  remplacer avec votre nom et votre mail
git config --global user.name "Barais Olivier" 
git config --global user.email "olivier.barais@univ-rennes1.fr"

# Initialiser le repo local
git init --initial-branch=main

# Initialiser le repo distant sur lequel vous enverrez votre code
# âš ï¸ mettre l'url en fonction de votre repo crÃ©Ã© sur gitlab
git remote add origin git@gitlab.istic.univ-rennes1.fr:obarais/tp1secuwebl3.git

# CrÃ©ation d'un fichier Readme.md pour placer votre rapport
touch Readme.md #Pour votre future rapport

# Ajout des fichiers Ã  suivre au sein de l'historique
git add Readme.md src/** package.json tsconfig.json

# Commit des modifications
git commit -m 'Initial commit'

# Premier push vers le repo distant en fixant que la branche local courante est Ã  placÃ© vers la branch main Ã  distance
git push --set-upstream origin main

# Ã  partir de lÃ , Ã  la fin de chaque question, vous pouvez faire
git commit . 
# afin de crÃ©er un nouveau snapshot de l'historique de vos fichiers
# et
git push
# pour envoyer l'historique vers gitlab
# âš ï¸ si vous crÃ©ez de nouveaux fichiers, il faudra les ajouter Ã  l'index en utilisant la commande git add. 
# N'oubliez pas de regarder par moment l'Ã©tat de votre repo en faisant un git status. 
# ğŸ‘¨ğŸ½â€ğŸ«:La qualitÃ© de l'utilisation de git sera Ã©valuÃ© dans la note globale des TPs
Step 8: Et les tests unitaires dans tout cela?
Q6 :
On va crÃ©er un test qui vÃ©rifie le comportement du getter de taille pour la classe RÃ©peroire.

npm install --save-dev jest @types/jest @jest/globals ts-jest
npx ts-jest config:init
Cela crÃ©e le fichier de configuration pour le driver de tests (ici on utilise jest).Le fichier gÃ©nÃ©rÃ© au dÃ©part ressemble Ã  :

/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  preset: 'ts-jest',